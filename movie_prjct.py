# -*- coding: utf-8 -*-
"""Movie_Prjct.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y-Z1K-6QK09gk8tGzj9tb46DApIJKFNS
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

"""# Data Cleaning and Manipulation"""

# Read CSV file of IMdb movies
imdb_movies = pd.read_csv('/content/drive/MyDrive/Data/Copy of IMDb movies.csv')

# See the information of dataset
imdb_movies.info()

# Drop the unwanted Columns 
imdb_movies.drop(['imdb_title_id','writer','date_published','description','reviews_from_users','reviews_from_critics','title','votes','usa_gross_income','metascore'],axis=1,inplace=True)

# Rename the columns 
imdb_movies.rename({'worlwide_gross_income':'worldwide_gross_income','avg_vote':'imdb_score','original_title':'movie_title'},axis=1,inplace=True)

# Drop the rows which have TV Movie 2019 in year column
imdb_movies.drop(imdb_movies.loc[imdb_movies.year == 'TV Movie 2019'].index, inplace=True)

# Convert the datatype of column year to int
imdb_movies['year'] = imdb_movies['year'].astype(int)

# Drop Nan values from dataset 
imdb_movies.dropna(inplace=True)

# Now check again the information of dataset
imdb_movies.info()

# Read CSV of rotten Tomatoes movies dataset
rotten_tomatoes = pd.read_csv('/content/drive/MyDrive/Data/rotten_tomatoes_movies.csv')

# Check information of rotten tomatoes dataset
rotten_tomatoes.info()

# Drop the unwanted Columns 
rotten_tomatoes.drop(['rotten_tomatoes_link', 'movie_info',
       'critics_consensus', 'content_rating', 'genres', 'directors', 'authors',
       'actors', 'streaming_release_date', 'runtime',
       'production_company', 'tomatometer_status',
       'tomatometer_count', 'audience_status', 'audience_rating',
       'audience_count', 'tomatometer_top_critics_count',
       'tomatometer_fresh_critics_count', 'tomatometer_rotten_critics_count'], axis=1 , inplace=True)

# See the information of dataset
rotten_tomatoes.info()

# Convert the original_release_date datatype to datetime 
rotten_tomatoes['original_release_date'] = pd.to_datetime(rotten_tomatoes['original_release_date'] )
# Extract year from original_release_date
rotten_tomatoes['year'] = rotten_tomatoes['original_release_date'].dt.strftime("%Y")

# drop rows in which year coloumns contains null values
rotten_tomatoes.drop(rotten_tomatoes.loc[rotten_tomatoes.year.isnull()].index, inplace=True)

# convert year datatype to int
rotten_tomatoes['year'] = rotten_tomatoes['year'].astype(int)
# drop original_release_date
rotten_tomatoes.drop(['original_release_date'], axis=1 , inplace=True)

# Now check again the information of dataset
rotten_tomatoes.info()

# Merge the imdb_movies and rotten_tomatoes datasets based on movie_title and year column
imdb_rotten = pd.merge(imdb_movies,rotten_tomatoes, on= ['movie_title','year'], how='inner')

imdb_rotten

# Select the data based on column worldwide_gross_income starts with $
imdb_rotten=imdb_rotten.loc[imdb_rotten['worldwide_gross_income'].str.startswith('$')]

# Select the data based on column budget starts with $
imdb_rotten=imdb_rotten.loc[imdb_rotten['budget'].str.startswith('$')]

# drop rows in which tomatometer_rating coloumn contains null values
imdb_rotten.drop(imdb_rotten.loc[imdb_rotten.tomatometer_rating.isnull()].index, inplace=True)

imdb_rotten.info()

# convert the datatype of worldwide_gross_income and budget after extracting the $ sign from them
imdb_rotten['worldwide_gross_income'] = imdb_rotten['worldwide_gross_income'].str.extract('(\d+)').astype(int)
imdb_rotten['budget'] = imdb_rotten['budget'].str.extract('(\d+)').astype(int)

imdb_rotten.info()

# Now reduce the scale of worldwide_gross_income and budget by 1000000
imdb_rotten['worldwide_gross_income'] = imdb_rotten['worldwide_gross_income']/1000000
imdb_rotten['budget'] = imdb_rotten['budget']/1000000
# Multiplying the imdb_score by 10 so it can easily relate with tomatometer reading
imdb_rotten['imdb_score'] = imdb_rotten['imdb_score']*10

imdb_rotten

# defining function for converting the columns contains multiple value in single row to a list
def convert_list(col):
  split_col = col.split(',')
  remove_spaces_col_list = [x.strip() for x in split_col]
  return remove_spaces_col_list

# convert genre col to list of genres for particular title
imdb_rotten['genre_list'] = imdb_rotten.apply(lambda row:convert_list(row['genre']),axis=1)

# Explode the genre list to individual genre into genre_list
imdb_rotten.drop(['genre'],axis=1,inplace=True)
imdb_rotten_genre_explode = imdb_rotten.explode('genre_list')

imdb_rotten_genre_explode

"""# EDA

## IMdb vs Tomatometer rating
"""

plt.figure (figsize=(12,6))
sns.set_style('darkgrid')
plt.title ('IMdb vs Tomatometer rating')
sns.boxplot(data = imdb_rotten_genre_explode[['imdb_score','tomatometer_rating']] )

"""From the above two plots we can observe that the most of the IMDB score are in a narrow band of 60 - 70 while most of the rotten tomatoes score lie in a bigger band of 30 - 80.

This might be due to the fact that audiences usually rate most of the movies averagely with less strictness i.e. movies are not usually rated at extremes

but critics have a more strict rating criteria so despite many movies being rated average, many of the other movies are either rated very high or very low.

Let's also try and draw histograms for the above 2 variables.

We will be using following bin values for the histograms
"""

bin_val = np.arange(0,101,10) # 0-10, 10-20, 20-30,.....90-100
plt.figure(figsize=(12,6))
plt.xticks(bin_val)
plt.hist(imdb_rotten_genre_explode.imdb_score,alpha=0.8,bins=bin_val)
plt.hist(imdb_rotten_genre_explode.tomatometer_rating,alpha=0.4,bins=bin_val)
plt.legend(['imdb','rotten tomatoes'])

"""Based on above 2 bar graphs we can clearly observe that imdb rating are mostly concentrated aroung the 50-70 range.

While tomatometer rating are very evenly distributed.

This also proves our initial assumption about the difference in rating behaviour of audience and critics.

Audiences usually rate most of the movies averagely with less strictness i.e. movies are not usually rated at extremes

but critics have a more strict rating criteria so despite many movies being rated average, many of the other movies are either rated very high or very low.

## Genre Vs Rating
"""

imdb_rotten_genre_explode

# find mean of genres
imdb_rotten_genre_mean =imdb_rotten_genre_explode.groupby('genre_list')['imdb_score', 'tomatometer_rating'].mean().reset_index()

imdb_rotten_genre_mean

# create figure and axis objects with subplots()
fig,ax = plt.subplots(figsize=(24,8))
# make a plot
ax.plot(imdb_rotten_genre_mean.genre_list, imdb_rotten_genre_mean.imdb_score, color="red", marker="o")
# set x-axis label
ax.set_xlabel("genre_list",fontsize=14)
# set y-axis label
ax.set_ylabel("imdb_score",color="red",fontsize=14)
# twin object for two different y-axis on the sample plot
ax2=ax.twinx()
# make a plot with different y-axis using second axis object
ax2.plot(imdb_rotten_genre_mean.genre_list, imdb_rotten_genre_mean["tomatometer_rating"],color="blue",marker="o")
ax2.set_ylabel("tomatometer_rating",color="blue",fontsize=14)
plt.show()

plt.figure(figsize=(20,8))
sns.barplot(x='genre_list', y='imdb_score', data=imdb_rotten_genre_explode)
# sns.barplot(x='genre_list', y='tomatometer_rating', data=imdb_rotten_genre_mean)

plt.figure(figsize=(20,8))
# sns.barplot(x='genre_list', y='imdb_score', data=imdb_rotten_genre_mean)
sns.barplot(x='genre_list', y='tomatometer_rating', data=imdb_rotten_genre_explode)

"""Analysis Points

Based on the above 2 plots, we can clrealy following points about genre preference according to two rating systems:


film-noir genre is more preferred in both of the rating system
Some genres like Animation, War, Western are equally preferred in both rating system.

Overall it seems that in tomatometer rating(usually most of the genres are rated around 50) the genre are rated less than Imdb ratings(usually most of the genres are rated around 60).

A good differnce in rating can be observed for following genre (usually for these genres, imdb mean rating is higher than rotten tomato mean rating)

Action

Comedy

Crime

Family

Thriller

## Year Vs Rating
"""

# Groupby year and find the median of imdb_score and tomatometer_rating based on year
imdb_rotten_rating_year =imdb_rotten_genre_explode.groupby('year')['imdb_score', 'tomatometer_rating'].median().reset_index()

imdb_rotten_rating_year

"""Plot Line graph with twinx feature of above data"""

# create figure and axis objects with subplots()
fig,ax = plt.subplots(figsize=(20,8))
# make a plot
ax.plot(imdb_rotten_rating_year.year, imdb_rotten_rating_year.imdb_score, color="red", marker="o")
# set x-axis label
ax.set_xlabel("year",fontsize=14)
# set y-axis label
ax.set_ylabel("imdb_score",color="red",fontsize=14)
# twin object for two different y-axis on the sample plot
ax2=ax.twinx()
# make a plot with different y-axis using second axis object
ax2.plot(imdb_rotten_rating_year.year, imdb_rotten_rating_year["tomatometer_rating"],color="blue",marker="o")
ax2.set_ylabel("tomatometer_rating",color="blue",fontsize=14)
plt.show()

"""Also plot scatter graph of above data"""

plt.figure(figsize=(30,10))
plt.title('Rating Vs Year')
sns.scatterplot(x=imdb_rotten_rating_year.year, y=imdb_rotten_rating_year.tomatometer_rating, s=100)
sns.scatterplot(x=imdb_rotten_rating_year.year, y=imdb_rotten_rating_year.imdb_score, s=100)
plt.legend(['tomatometer_rating','imdb_score'])

"""**Analysis Point**

1. As times goes on the tomatometer rating declined as compared to imdb_score  and vice versa.
2. The imdb_score almost constant after year 1980, which lies between in the range of 60 -70.
3. The tomatometer rating increses slightly after year 2000.

## genre total movie count
"""

# Groupby the movies according to genre and count based on year 
imdb_rotten_year_movie_count =imdb_rotten_genre_explode.groupby('genre_list')['year'].count().reset_index()

imdb_rotten_year_movie_count

plt.figure(figsize=(20,8))
plt.yticks(np.arange(0,3000,250))
sns.barplot(x='genre_list', y='year', data=imdb_rotten_year_movie_count);

"""**Analysis Point**

1. Throughout the data the Drama genre made mostly i.e. 2682 followed by comedy (2051) compared to others.
2. film noir movies are less made only 10 in counts

## genre_year_movie_count
"""

imdb_rotten_genre_explode.year.nunique()

# create dataset with feature genre_list and year and grouby them on the count.
imdb_rotten_genre_year_movie_count = imdb_rotten_genre_year.groupby(['genre_list','year'])['imdb_score'].count().reset_index()

imdb_rotten_genre_movie_count_year = imdb_rotten_genre_year_movie_count.groupby(['genre_list'])['year'].count().reset_index()

imdb_rotten_genre_movie_count_year

plt.figure(figsize=(20,8))
plt.yticks(np.arange(0,3000,250))
sns.barplot(x='genre_list', y='year', data=imdb_rotten_genre_movie_count_year);

"""**Analysis Point**

1. Throughout 94 years drama genre movies released in 89 years followed by Romance (80) and comedy (77).
2. Film Noir is the least released in only 9 years.

## Year Budget Gross Income
"""

# create dataset with features 'year','budget','worldwide_gross_income'
yr_budget_income = imdb_rotten_genre_explode[['year','budget','worldwide_gross_income']]

# drop duplicate rows
yr_budget_income.drop_duplicates(inplace=True)

yr_budget_income

"""now draw the scatter plot for above dataset """

plt.figure(figsize=(20,8))
sns.scatterplot(x='year', y='budget', data = yr_budget_income, s=25);

plt.figure(figsize=(20,8))

sns.scatterplot(x='year', y='worldwide_gross_income', data = yr_budget_income, s=25);

plt.figure(figsize=(20,8))

sns.scatterplot(x='budget', y='worldwide_gross_income', data = yr_budget_income, s=25);

"""**Analysis Point**

1. As we can see from above scatter plots, over the years the budget increases hence the gross income also increases.

Now plot correlation matrix between them
"""

correlation_yr_budget_income = yr_budget_income.corr()

correlation_yr_budget_income

sns.heatmap(correlation_yr_budget_income, annot=True, cmap='Blues')

"""**Analysis Point**

1. As we can see from above scatter plots, over the years the budget increases hence the gross income also increases.
2. And it is also seen from the correlation matrix that budget and gross income highly correlated with coefficient of 0.74 .

## Duration Rating
"""

# Create dataset for 'duration','imdb_score','tomatometer_rating'
duration_rating = imdb_rotten_genre_explode[['duration','imdb_score','tomatometer_rating']]
duration_rating

# Drop duplicate rows 
duration_rating.drop_duplicates(inplace=True)

"""Plot scatter graph for selected data for duration with tomatometer rating and imdb_score """

plt.figure(figsize=(20,8))
sns.scatterplot(x='duration', y='imdb_score', data = duration_rating, s=25);

plt.figure(figsize=(20,8))
sns.scatterplot(x='duration', y='tomatometer_rating', data = duration_rating, s=25);

"""Not such insight can drawn from above plots 
so let's see any insight can drawn by correlation between them.
"""

duration_rating_correlation = duration_rating.corr()

sns.heatmap(duration_rating_correlation, annot=True, cmap='Blues')

"""**Analysis Point**

From correlation matrix it is observed that the duration is not highly correlated with imdb score and tomatometer rating

## Duration Income
"""

# Create dataset with features 'duration','worldwide_gross_income'
duration_income =imdb_rotten_genre_explode[['duration','worldwide_gross_income']]
duration_income.drop_duplicates(inplace=True)

"""Plot the scatter plot"""

plt.figure(figsize=(20,8))
sns.scatterplot(x='duration', y='worldwide_gross_income', data = duration_income, s=25);

"""## Duration Genre"""

# Create dataframe with feature 'duration','genre_list', then remove duplicates rows
duration_genre = imdb_rotten_genre_explode[['duration','genre_list']]
duration_genre.drop_duplicates(inplace= True)

duration_genre

"""Plot a box plot"""

plt.figure(figsize= (20,8))
sns.boxplot(x='genre_list', y='duration', data= duration_genre );

plt.figure(figsize= (20,8))
sns.barplot(x='genre_list', y='duration', data= duration_genre );

"""**Analysis Point**

1. History and Drama genre movies are almost around 140 min, which is higher duration compared to other genres.
2. Animation genre movies has the lowest duration amongst other genres.

## Rating Language
"""

# create dataframe with selected column 'language','imdb_score','tomatometer_rating'
rating_language = imdb_rotten_genre_explode[['language','imdb_score','tomatometer_rating']]
# Drop Duplicates rows 
rating_language.drop_duplicates(inplace=True)

# Explode the col language and remove duplicates rows
rating_language['language'] = rating_language.apply(lambda row:convert_list(row['language']),axis=1)
rating_language = rating_language.explode('language') 
rating_language.drop_duplicates(inplace=True)

# Drop rows having language col none values
rating_language.drop(rating_language.loc[rating_language.language == 'None'].index, inplace=True)

# Check the values of language col 
print(rating_language.language.unique())
print(rating_language.language.nunique())

"""Their are 136 languages in which movies are released we can not plot all languages in one graph, so we have to restrict it for particular languages.

So we have to select the 'English', 'Latin', 'German', 'French', 'Italian', 'Russian', 'Arabic', 'Spanish', 'Japanese', 'Chinese', 'Hindi', 'Korean' languages
"""

rating_language= rating_language.loc[rating_language.language.isin(['English', 'Latin', 'German', 'French', 'Italian', 'Russian', 'Arabic', 'Spanish', 'Japanese', 'Chinese', 'Hindi', 'Korean'])]

plt.figure(figsize= (20,8))
sns.barplot(x='language', y='imdb_score',  data= rating_language );

plt.figure(figsize= (20,8))
sns.barplot(x='language', y='tomatometer_rating',  data= rating_language );

"""**Analysis Point**

1. Their is not such significant change in imdb score with languages but one insight is observed that English language has lowest rating as compared to other languages.
2. Their is much variation seen in the tomatometer rating as compared to imdb score with languages, in which German language has highest tomatometer rating followed by hindi while japanese has lowest tomatomete rating

## Genre Income
"""

# Create dataset with features imdb_rotten_genre_explode and remove duplicate rows
genre_income = imdb_rotten_genre_explode[['genre_list', 'worldwide_gross_income']].copy()
genre_income.drop_duplicates(inplace=True)

# plot bar graph for above data
plt.figure(figsize=(20,8))
sns.barplot(x='genre_list', y='worldwide_gross_income', data=genre_income);

# plot box graph for above data
plt.figure(figsize=(20,8))
sns.boxplot(x='genre_list', y='worldwide_gross_income', data=genre_income);

"""**Analysis point**

1. From the bar plot it is clearly observed that animation genre movies earned higher than other genres and also have less outliers as seen in box plot. 
2. After animation genre, the adventure movies have high world gross income but it has too much heavy outliers in it as seen in box plot.
3. Genre film-noir has the lowest earning, this is because this genre is obslette nowdays.

## Country Income
"""

# create dataset with feature 'country','worldwide_gross_income' then explode country col and drop duplicates
country_income= imdb_rotten_genre_explode[['country','worldwide_gross_income']].copy()
country_income['country'] = country_income.apply(lambda row:convert_list(row['country']),axis=1)
country_income = country_income.explode('country') 
country_income.drop_duplicates(inplace=True)

# find the number of unique values in country
print(country_income.country.unique())
print(country_income.country.nunique())

"""Since the number of country is 81 so we restricted it to selected countries'USA', 'France', 'Mexico', 'UK', 'Italy', 'Japan', 'Spain', 'Australia', 'South Africa', 'India', 'Germany', 'China','Russia'."""

country_income= country_income.loc[country_income.country.isin(['USA', 'France', 'Mexico', 'UK', 'Italy', 'Japan', 'Spain', 'Australia', 'South Africa', 'India', 'Germany', 'China','Russia'])]

"""Plot the bar plot and box plot """

plt.figure(figsize=(20,8))
sns.barplot(x='country', y='worldwide_gross_income', data=country_income);

plt.figure(figsize=(20,8))
sns.boxplot(x='country', y='worldwide_gross_income', data=country_income);

"""**Analysis Point**

1. China has the highest gross income with some outliers followed by japan.
2. USA has the maximum outliers while russia has minimum outliers.

## Language Income
"""

# create dataset with feature 'language','worldwide_gross_income'
language_income = imdb_rotten_genre_explode[['language','worldwide_gross_income']].copy()

language_income

# Convert the languages to list
language_income['language'] = language_income.apply(lambda row:convert_list(row['language']),axis=1)

# Explode the languages and drop duplicates
language_income = language_income.explode('language') 
language_income.drop_duplicates(inplace=True)

"""As the number of languages are more so we have to restrict it with selected languages 'English', 'Latin', 'German', 'French', 'Italian', 'Russian', 'Arabic', 'Spanish', 'Japanese', 'Chinese', 'Hindi', 'Korean'"""

language_income= language_income.loc[language_income.language.isin(['English', 'Latin', 'German', 'French', 'Italian', 'Russian', 'Arabic', 'Spanish', 'Japanese', 'Chinese', 'Hindi', 'Korean'])]

# plot the barplot for selected languages
plt.figure(figsize=(20,8))
sns.barplot(x='language', y='worldwide_gross_income', data=language_income);

# plot the boxplot for selected languages
plt.figure(figsize=(20,8))
sns.boxplot(x='language', y='worldwide_gross_income', data=language_income);

"""**Analysis Point**

1. It is seen that the earnings are more in japanese languages it also have some heavy outliers followed by the korean languages with less outliers.
2. while the earning in english is lowest as compared to other selected languages with too much outliers.

# Final Results

1. We can observe that the most of the IMDB score are in a narrow band of 60 - 70 while most of the rotten tomatoes score lie in a bigger band of 30 - 80.

    This might be due to the fact that audiences usually rate most of the movies averagely with less strictness i.e. movies are not usually rated at extremes

    but critics have a more strict rating criteria so despite many movies being rated average, many of the other movies are either rated very high or very low.

2. Film-noir genre is more preferred in both of the rating system Some genres like Animation, War, Western are equally preferred in both rating system.

3. As times goes on the tomatometer rating declined as compared to imdb_score and vice versa.

4. English language has lowest rating as compared to other languages in both imdb and rottrn tomatoes.

5. The duration is not highly correlated with imdb score and tomatometer rating.

6. Animation genre movies earned higher than other genres.

7. Movies released in japanese language earns more as released in other languages.

8. China has the highest gross income as compared to other countries.

9. History and Drama genre movies are almost around 140 min, which is higher duration compared to other genres.
Animation genre movies has the lowest duration amongst other genres.

10. Throughout years the Drama genre movies are released most i.e. 2682 followed by comedy (2051) compared to others..Throughout 94 years drama genre movies released in 89 years followed by Romance (80) and comedy (77).

11. Over the years the budget increases hence the gross income also increases.
And it is also seen from the correlation matrix that budget and gross income highly correlated with coefficient of 0.74 .
"""